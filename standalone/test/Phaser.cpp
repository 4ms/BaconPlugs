#include "Phaser.hpp"
#include "standalone_helpers.hpp"

#define CATCH_CONFIG_MAIN
#include "catch.hpp"

// Some utilities to match the python
#include <math.h>
#include <vector>

typedef std::vector< float > flvec;

flvec sinbuf( float freq )
{
  int n = engineGetSampleRate() / 10;
  flvec result;
  for( int i=0; i<n; ++i )
    {
      float t = 1.0f * i / engineGetSampleRate();
      result.push_back( sin( t * 2 * M_PI * freq ) );
    }
  return result;
}

float bufMag( flvec buf )
{
  float sumsq = 0;
  for( auto f : buf )
    sumsq += f * f;
  sumsq /= buf.size();
  return sqrt( sumsq ) / sqrt( 2.0f );
}

float rmsAtF( AllPassFilter &a, float freq )
{
  flvec sinb = sinbuf( freq );
  flvec res;
  for( auto f : sinb ) res.push_back( a.process( f ) + f );
  return bufMag( res );
}

float rmsAtF( float zR, float zI, float freq )
{
  AllPassFilter apf;
  apf.setComplex( zR, zI );
  return rmsAtF( apf, freq );
}


TEST_CASE( "All Pass Filter generates min per python" )
{
  // This code is generated by the pynb notebook
  CHECK( rmsAtF( 0.98, 0.04,  100 ) == Approx( 0.957165f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  200 ) == Approx( 0.742463f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  300 ) == Approx( 0.148971f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  400 ) == Approx( 0.479301f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  500 ) == Approx( 0.737406f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.850000, 0.100000, 940.000000 ) ==  Approx( 0.430219f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.100000, 0.850000, 10643.000000 ) ==  Approx( 0.368515f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.931063, 0.188736, 1700.000000 ) ==  Approx( 0.543379f ).margin( 5e-5 ) );
}

TEST_CASE( "All Pass Filter matches python under zR zI changes" )
{
}
